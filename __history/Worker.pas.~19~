unit Worker;

interface

uses
  System.SysUtils, System.Classes, System.JSON, System.IOUtils, Math, Generics.Collections;

type
  TSendungInfo = class
  public
    Anbieter: string;
    ProduktName: string;
    Typ: string;
    Preis: Double;
  end;

  TWorker = class
  public
    function FindePassendeSendungen(L, B, H, Gewicht: Double; Express, Einschreiben: Boolean): TList<TSendungInfo>;
    procedure PrüfeSendung(L, B, H, Gewicht: Double; Express, Einschreiben: Boolean); // Beibehalten für die Konsolenausgabe (optional)
  end;

implementation

function TWorker.FindePassendeSendungen(L, B, H, Gewicht: Double; Express, Einschreiben: Boolean): TList<TSendungInfo>;
var
  JsonStr: string;
  Json: TJSONObject;
  Sendungen: TJSONArray;
  Sendung, Maße, Optionen: TJSONObject;
  I: Integer;
  LängeMin, LängeMax, BreiteMin, BreiteMax, HöheMax, MaxGewicht: Double;
  Typ, Anbieter, ProduktName: string;
  Preis: Double;
  Seiten: TArray<Double>;
  MinSeite, MaxSeite: Double;
  SendungInfo: TSendungInfo;
begin
  Result := TList<TSendungInfo>.Create;
  JsonStr := TFile.ReadAllText('anbieter.json');
  Json := TJSONObject.ParseJSONValue(JsonStr) as TJSONObject;
  Sendungen := Json.GetValue<TJSONArray>('sendungen');

  for I := 0 to Sendungen.Count - 1 do
  begin
    Sendung := Sendungen.Items[I] as TJSONObject;
    Typ := Sendung.GetValue<string>('typ');
    Anbieter := Sendung.GetValue<string>('anbieter');
    ProduktName := Sendung.GetValue<string>('name');
    Maße := Sendung.GetValue<TJSONObject>('maß_cm');
    Optionen := Sendung.GetValue<TJSONObject>('optionen');

    LängeMin := Maße.GetValue<Double>('länge_min');
    LängeMax := Maße.GetValue<Double>('länge_max');
    BreiteMin := Maße.GetValue<Double>('breite_min');
    BreiteMax := Maße.GetValue<Double>('breite_max');
    HöheMax := Maße.GetValue<Double>('höhe_max');
    MaxGewicht := Sendung.GetValue<Double>('max_gewicht_g');
    Preis := Sendung.GetValue<Double>('preis_euro');

    if Express then
      Preis := Preis + Optionen.GetValue<Double>('express');

    if Einschreiben then
      Preis := Preis + Optionen.GetValue<Double>('einschreiben');

    // Wenn Anbieter Hermes/GLS ist, berücksichtige nur die längste und kürzeste Seite
    if (Anbieter = 'Hermes') or (Anbieter = 'GLS') then
    begin
      // Bestimme die größte und kleinste Seite
      Seiten := [L, B, H];
      MinSeite := Min(Min(Seiten[0], Seiten[1]), Seiten[2]);
      MaxSeite := Max(Max(Seiten[0], Seiten[1]), Seiten[2]);

      // Vergleiche mit den erlaubten Maßen
      if (MaxSeite >= LängeMin) and (MinSeite >= BreiteMin) and (Gewicht <= MaxGewicht) then
      begin
        SendungInfo := TSendungInfo.Create;
        SendungInfo.Anbieter := Anbieter;
        SendungInfo.ProduktName := ProduktName;
        SendungInfo.Typ := Typ;
        SendungInfo.Preis := Preis;
        Result.Add(SendungInfo);
      end;
    end
    else
    begin
      // Für alle anderen Anbieter bleibt die Standardberechnung
      if (L >= LängeMin) and (L <= LängeMax) and
          (B >= BreiteMin) and (B <= BreiteMax) and
          (H <= HöheMax) and
          (Gewicht <= MaxGewicht) then
      begin
        SendungInfo := TSendungInfo.Create;
        SendungInfo.Anbieter := Anbieter;
        SendungInfo.ProduktName := ProduktName;
        SendungInfo.Typ := Typ;
        SendungInfo.Preis := Preis;
        Result.Add(SendungInfo);
      end;
    end;
  end;

  Json.Free;
end;

procedure TWorker.PrüfeSendung(L, B, H, Gewicht: Double; Express, Einschreiben: Boolean);
var
  PassendeSendungen: TList<TSendungInfo>;
  SendungInfo: TSendungInfo;
  I: Integer;
begin
  PassendeSendungen := FindePassendeSendungen(L, B, H, Gewicht, Express, Einschreiben);
  try
    for I := 0 to PassendeSendungen.Count - 1 do
    begin
      SendungInfo := PassendeSendungen[I];
      Writeln('✅ Anbieter: ', SendungInfo.Anbieter);
      Writeln('📦 Produkt: ', SendungInfo.ProduktName);
      Writeln('📦 Typ: ', SendungInfo.Typ);
      Writeln('💶 Preis: ', FormatFloat('0.00', SendungInfo.Preis), ' €');
      Writeln('---');
    end;
  finally
    PassendeSendungen.Free;
  end;
end;

end.
